"""Base strategy class for all trading strategies."""

from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import date, datetime, timedelta
from typing import Dict, List, Optional, Tuple, Any
from enum import Enum
import pandas as pd

from src.database import Trade, Filer, PriceData


class SignalType(Enum):
    """Types of trading signals."""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"


@dataclass
class StrategySignal:
    """A trading signal generated by a strategy."""
    
    ticker: str
    signal_type: SignalType
    strength: float  # 0.0 to 1.0
    entry_date: date
    exit_date: Optional[date] = None
    entry_price: Optional[float] = None
    exit_price: Optional[float] = None
    position_size: float = 1.0  # Fraction of portfolio
    
    # Metadata about the signal
    trigger_trades: List[int] = None  # Trade IDs that triggered this signal
    reasoning: str = ""
    
    def __post_init__(self):
        if self.trigger_trades is None:
            self.trigger_trades = []


@dataclass 
class StrategyResult:
    """Results from executing a strategy."""
    
    strategy_name: str
    signals: List[StrategySignal]
    start_date: date
    end_date: date
    
    # Performance metrics (calculated later)
    total_return: Optional[float] = None
    win_rate: Optional[float] = None
    total_trades: int = 0
    
    # Additional metadata
    parameters: Dict[str, Any] = None
    
    def __post_init__(self):
        if self.parameters is None:
            self.parameters = {}
        self.total_trades = len(self.signals)


class BaseStrategy(ABC):
    """Base class for all trading strategies."""
    
    def __init__(self, name: str, **parameters):
        """Initialize strategy with parameters.
        
        Args:
            name: Strategy name
            **parameters: Strategy-specific parameters
        """
        self.name = name
        self.parameters = parameters
        
        # Default parameters that all strategies can use
        self.min_position_size = parameters.get('min_position_size', 0.01)  # 1%
        self.max_position_size = parameters.get('max_position_size', 0.1)   # 10%
        self.min_trade_amount = parameters.get('min_trade_amount', 15000)   # $15k minimum
        self.holding_period_days = parameters.get('holding_period_days', 45)
        
    @abstractmethod
    def generate_signals(self, trades: List[Trade], 
                        start_date: date, end_date: date) -> StrategyResult:
        """Generate trading signals based on insider trades.
        
        Args:
            trades: List of insider/politician trades
            start_date: Start date for signal generation
            end_date: End date for signal generation
            
        Returns:
            StrategyResult containing generated signals
        """
        pass
    
    def filter_trades(self, trades: List[Trade], 
                     start_date: date, end_date: date) -> List[Trade]:
        """Filter trades based on strategy criteria.
        
        Args:
            trades: All available trades
            start_date: Start date for filtering
            end_date: End date for filtering
            
        Returns:
            Filtered list of trades
        """
        filtered = []
        
        for trade in trades:
            # Date filter
            trade_date = trade.reported_date or trade.trade_date
            if not trade_date or trade_date < start_date or trade_date > end_date:
                continue
            
            # Amount filter
            if trade.amount_usd and trade.amount_usd < self.min_trade_amount:
                continue
            
            # Must have ticker
            if not trade.ticker:
                continue
            
            filtered.append(trade)
        
        return filtered
    
    def calculate_position_size(self, trade: Trade, 
                              portfolio_value: float = 100000) -> float:
        """Calculate position size based on trade amount and portfolio value.
        
        Args:
            trade: The trade to size
            portfolio_value: Total portfolio value
            
        Returns:
            Position size as fraction of portfolio (0.0 to 1.0)
        """
        if not trade.amount_usd:
            return self.min_position_size
        
        # Base position size on trade amount relative to portfolio
        base_size = trade.amount_usd / portfolio_value
        
        # Clamp to min/max limits
        position_size = max(self.min_position_size, 
                           min(self.max_position_size, base_size))
        
        return position_size
    
    def calculate_exit_date(self, entry_date: date, 
                          holding_period: Optional[int] = None) -> date:
        """Calculate exit date based on holding period.
        
        Args:
            entry_date: Date of entry
            holding_period: Holding period in days (uses default if None)
            
        Returns:
            Exit date
        """
        days = holding_period or self.holding_period_days
        return entry_date + timedelta(days=days)
    
    def group_trades_by_ticker(self, trades: List[Trade]) -> Dict[str, List[Trade]]:
        """Group trades by ticker symbol.
        
        Args:
            trades: List of trades to group
            
        Returns:
            Dictionary mapping ticker to list of trades
        """
        grouped = {}
        for trade in trades:
            if trade.ticker:
                if trade.ticker not in grouped:
                    grouped[trade.ticker] = []
                grouped[trade.ticker].append(trade)
        return grouped
    
    def group_trades_by_filer(self, trades: List[Trade]) -> Dict[int, List[Trade]]:
        """Group trades by filer ID.
        
        Args:
            trades: List of trades to group
            
        Returns:
            Dictionary mapping filer_id to list of trades
        """
        grouped = {}
        for trade in trades:
            if trade.filer_id not in grouped:
                grouped[trade.filer_id] = []
            grouped[trade.filer_id].append(trade)
        return grouped
    
    def calculate_signal_strength(self, trades: List[Trade]) -> float:
        """Calculate signal strength based on trade characteristics.
        
        Args:
            trades: List of trades contributing to the signal
            
        Returns:
            Signal strength between 0.0 and 1.0
        """
        if not trades:
            return 0.0
        
        strength_factors = []
        
        # Factor 1: Number of trades (more = stronger)
        num_trades_factor = min(len(trades) / 5.0, 1.0)  # Max at 5 trades
        strength_factors.append(num_trades_factor)
        
        # Factor 2: Total amount (larger = stronger)
        total_amount = sum(t.amount_usd for t in trades if t.amount_usd)
        if total_amount > 0:
            # Normalize to 0-1 scale (max at $1M)
            amount_factor = min(total_amount / 1000000, 1.0)
            strength_factors.append(amount_factor)
        
        # Factor 3: Filer diversity (more filers = stronger)
        unique_filers = len(set(t.filer_id for t in trades))
        filer_factor = min(unique_filers / 3.0, 1.0)  # Max at 3 filers
        strength_factors.append(filer_factor)
        
        # Factor 4: Recency (more recent = stronger)
        if trades[0].reported_date:
            days_ago = (date.today() - trades[0].reported_date).days
            recency_factor = max(0, 1.0 - (days_ago / 90))  # Decay over 90 days
            strength_factors.append(recency_factor)
        
        # Average all factors
        return sum(strength_factors) / len(strength_factors)
    
    def validate_parameters(self) -> List[str]:
        """Validate strategy parameters.
        
        Returns:
            List of validation error messages (empty if valid)
        """
        errors = []
        
        if self.min_position_size <= 0 or self.min_position_size > 1:
            errors.append("min_position_size must be between 0 and 1")
        
        if self.max_position_size <= 0 or self.max_position_size > 1:
            errors.append("max_position_size must be between 0 and 1")
        
        if self.min_position_size >= self.max_position_size:
            errors.append("min_position_size must be less than max_position_size")
        
        if self.min_trade_amount <= 0:
            errors.append("min_trade_amount must be positive")
        
        if self.holding_period_days <= 0:
            errors.append("holding_period_days must be positive")
        
        return errors
    
    def get_strategy_info(self) -> Dict[str, Any]:
        """Get information about the strategy.
        
        Returns:
            Dictionary with strategy information
        """
        return {
            "name": self.name,
            "parameters": self.parameters.copy(),
            "description": self.__doc__ or "No description available"
        }


class LagTradeStrategy(BaseStrategy):
    """Strategy that trades with a delay after insider disclosure."""
    
    def __init__(self, lag_days: int = 1, **parameters):
        """Initialize lag trade strategy.
        
        Args:
            lag_days: Number of days to wait after disclosure before trading
            **parameters: Other strategy parameters
        """
        super().__init__("Lag Trade Strategy", lag_days=lag_days, **parameters)
        self.lag_days = lag_days
    
    def generate_signals(self, trades: List[Trade], 
                        start_date: date, end_date: date) -> StrategyResult:
        """Generate lag trade signals."""
        
        # Filter relevant trades
        filtered_trades = self.filter_trades(trades, start_date, end_date)
        
        # Only look at buy transactions
        buy_trades = [t for t in filtered_trades 
                     if t.transaction_type.value in ['buy', 'option_buy']]
        
        signals = []
        
        for trade in buy_trades:
            # Calculate entry date (disclosure date + lag)
            disclosure_date = trade.reported_date or trade.trade_date
            if not disclosure_date:
                continue
            
            entry_date = disclosure_date + timedelta(days=self.lag_days)
            
            # Skip if entry date is outside our backtesting window
            if entry_date < start_date or entry_date > end_date:
                continue
            
            exit_date = self.calculate_exit_date(entry_date)
            position_size = self.calculate_position_size(trade)
            
            signal = StrategySignal(
                ticker=trade.ticker,
                signal_type=SignalType.BUY,
                strength=self.calculate_signal_strength([trade]),
                entry_date=entry_date,
                exit_date=exit_date,
                position_size=position_size,
                trigger_trades=[trade.trade_id],
                reasoning=f"Lag trade: {self.lag_days} days after {trade.filer.name} bought ${trade.amount_usd:,.0f}"
            )
            
            signals.append(signal)
        
        return StrategyResult(
            strategy_name=self.name,
            signals=signals,
            start_date=start_date,
            end_date=end_date,
            parameters={"lag_days": self.lag_days, **self.parameters}
        )
